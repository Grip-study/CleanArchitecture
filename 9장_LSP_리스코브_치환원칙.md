# LSP 리스코프 치환 원칙

```
S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, 
T 타입을 이용해서 정의한 모든 프로그램 P에서 
o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, 
S는 T의 하위 타입이다. 
```

## 상속을 사용하도록 가이드하기
- License 클래스
- License 클래스의 하위타입 PersonalLicense, BusinessLicense
- License 클래스를 사용하는 Billing 애플리케이션

=> Billing 애플리케이션은 License의 하위 타입 중 무엇을 사용해도 동일하게 동작

인터페이스 또는 상위 클래스를 바라보면서 어떤 하위 타입을 사용하는지에 전혀 의존하지 않는다. <br>
이들 하위 타입은 인터페이스 타입과 치환할 수 있다. <br>
=> LSP 를 준수함


## 정사각형/직사각형 문제
LSP를 위반하는 전형적인 문제

- Rectangle 클래스
- Rectangle 클래스의 하위타입 Sqaure

=> 
- Rectangle은 높이와 너비가 서로 독립적으로 변경될 수 있으나, Sqare는 높이와 너비가 반드시 함께 변경 되어야 함.
- 따라서, Rectangle 클래스를 이용하는 User 클래스에서는 Sqare로 이용하게 될 때 문제가 발생한다. 
- 이 문제를 해결하기 위해서는 User 클래스에 Rectangle이 실제로 Square인지 검사하는 메커니즘을 추가해야 하는데, 이렇게 하면 User의 행위가 사용하는 타입에 의존하게 됨.
- 결국 Sqare 클래스는 Rectangle 클래스와 치환할 수 없음.


## LSP 와  아키텍처
LSP는 상속에서만이 아니라, 아키텍처 수준으로 확장할 수 있다.
- 인터페이스와 이를 구현하는 여러 개의 클래스
- 동일한 메서드 시그니처를 공유하는 여러 개의 클래스
- 동일한 REST 인터페이스에 읃압하는 서비스 집단

=> 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리 상호 치환 가능성이 필요

=> 아키텍처 관점에서 LSP를 잘 이해하려면, 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰해야 한다.


## LSP 위배 사례
LSP가 잘 지켜지지 않으면 이 예외 상황을 처리하는 로직을 추가해야 한다. 

최대한 LSP를 잘 지키되, 지켜지지 못한 상황이 일어나면 if문을 추가하는 것보다는

이와 같은 예외 상황을 설정용 데이터베이스를 이용하는 등 시스템으로부터 격리한다. 


## 결론
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가할 수도 있게 됨.

아키텍처 수준까지 LSP를 고려해라ㅏㅏ~~~~

